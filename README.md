# Subjective-Dissimilarity-and-Discrimination-Capacity 
 
This is the repository for the paper **Is subjective perceptual similarity metacognitive?** It is broken down into several directories, listed below. Each section will be described in more detail.

1. **Analysis Code** - Used for analyzing and making charts from the collected data.
2. **Collected Data** - Log files gathered from subjects while running the experiment.
3. **Near Threshold Discrimination Task/src** - Source code for the near-threshold discrimination task.
4. **Prepare Faces and Morphs** - Source code used to prepare the faces and morphs for the tasks.
5. **Subjective Similarity Judgment Task** - Source code for the subjective similarity judgment task.

## Near Threshold Discrimination Task
The near-threshold discrimination task is an interleaved staircase task where subjects discriminate between morphs of selected face pairs. Each staircase represents one face pair with 1000 morphs between them. Each face is assigned an integer ID. For example, for the face pair `1-99`, `1-99.1` represents the first morph for this pair, which is equal to face 1. Similarly `1-99.1000` is the 1000th morph for this pair, which is equal to face 99. In each iteration, the staircase shows three faces. It randomly chooses a morph *n*, and shows the morph with ID `n` twice. It also stores an integer distance *k*, also known as the intensity, to use for each iteration, and shows a morph which is *k* away from the face *n*, i.e. `n±k`, once. Whether the applied intensity is positive or negative is chosen at random. The range from which *n* is randomly chosen is constrained such that `n±k` will always be between 1 and 1000. The intensity is controlled by a set of rules passed to `StairHandlerGetIntensity`, which in this experiment specifies a 2-down/1-up staircase with decreasing step sizes upon reversals. 

The experiment tests multiple face pairs at once. Each of the face pairs is represented by one staircase, and these staircases are interleaved such that they are shown in a random sequence to the subject. In every iteration, each staircase is shown once. At the end of the iteration, the order of the staircases is shuffled. Then, the next iteration begins. This process is repeated until the number of iterations `exp_info["n_trials"]` is hit.

### Logging
Logging is done manually, with both an `experiment.csv` log which records information about each click, and an individual log per staircase which tracks responses, reversals, and intensities for the individual staircase.

The `experiment.csv` log is generated by saving information from every click to a list object `experiment_log_tracker`, which is written to a CSV at the end of each iteration. 

The staircase log is handled by the `StaircaseLogger` class, which writes reversals and responses. This is also written at the end of each iteration. Note that the staircase log is written with the labels as rows, while the `experiment.csv` log is written with the labels as columns. This was done because the built-in PsychoPy staircase logging uses row-based labeling.

### PsychoPy
This experiment runs on PsychoPy 2023, using Python version 3.8. 

## Subjective Similarity Judgment Task
The subjective similarity judgment task is a similarity task where subjects rank candidate faces based on how similar they are to a target face. This task's purpose is to generate the subject's subjective similarity matrix for each face pair, where similarity is measured as a floating point number between 0 and 1. This similarity measure is correlated against the subject's performance in the Near Threshold Discrimination Task described above for the same face pairs, which points to the metacognitive link between subjective perception and face distinguishability.  

The subject's similarity space is represented by a 2-dimensional matrix embedding, which we generate by passing an actual similarity distance matrix to scikit-learn's [multidimensional scaling](https://scikit-learn.org/stable/modules/manifold.html#multidimensional-scaling) (MDS) `fit_transform` algorithm. The initial similarity matrix is based on burn-in trials where the candidate faces, also known as the *body*, are selected at random, and the user's responses are used to seed said matrix. Outside of burn-in trials, the body is chosen by using a combination of algorithms based off of, and partially sourced from, **‌Active Ordinal Querying for Tuplewise Similarity Learning** (Canal, 2019). Specifically, the output embedding from the MDS of the actual distance matrix are passed to a body selector, which selects candidates that will maximize information gained from the subjects' ranking of the selected candidates. For more information on the body selector algorithm, refer to Canal 2019. 

### Code motion
1. Burn-in iterations, where candidates are chosen at random, are used to seed the initial similarity matrix.
2. An initial MDS is run on the output of the burn-in iterations. This initial MDS uses non metric MDS to account for the large number of missing values from the burn-in.
3. For each iteration:
	1. For each face in the dataset:
		1. Run the body selector where this face is the candidate face.
		2. Show the results on the screen and have the subject rank the candidate faces.
	2. Generate a new dissimilarity matrix based on the subject's rankings this round (one ranking set for each face).
	3. Run metric MDS `fit_transform` on the new dissimilarity matrix, using the embedding output of the previous MDS as the seed. We use metric for all non burn-in iterations because it maintains the actual pairwise distance of the subject's rankings, there are fewer zeros as a result of the burn-in iterations, and we can use the previous MDS as the seed. Furthermore, in our own testing, metric MDS produced better results, i.e. embedding matrices with higher correlation to randomly generated test matrices when compared to non metric MDS.
4. Find all remaining face pairs in the dissimilarity matrix which have no data associated with them, and run backfill trials to fill in missing data using the process described in (3).
5. Save the dissimilarity matrix and the embedding from the experiment for later use.

### Similarity matrix formula
Our raw similarity matrix uses a simple formula which tracks each *x, y* face pair. The number of times *x* and *y* were compared, where either *x* or *y* was the target face, and the other face was chosen as first or second closest, is stored as the denominator. The number of times the other face was chosen as first place *only* is stored as the numerator. This ratio is the similarity value.
